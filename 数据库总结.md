# 数据库知识点总结

[1. 事务](#1. 事务)

- [ACID 特性](#ACID 特性)
- [常见的并发异常](#常见的并发异常)
- [事务的隔离级别](#事务的隔离级别)
- [事务隔离性的实现](#事务隔离性的实现)
- [日志恢复技术](#日志恢复技术)
- [检查点技术](#检查点技术)

[2. 数据库引擎](#2. 数据库引擎)

- [数据库引擎的类型](#数据库引擎的类型)
- [InnoDB 与 MyISAM 差别](#InnoDB 与 MyISAM 差别)

[3. 索引](#3. 索引)

- [B树和B+树的区别](#B树和B+树的区别)
- [使用B树索引的好处](#使用B树索引的好处)
- [使用B+树索引的好处](#使用B+树索引的好处)
- [使用Hash索引的特点](#使用Hash索引的特点)
- [为何不用B树索引](#为何不用B树索引)
- [为何不用AVL树索引](#为何不用AVL树索引)
- [为何不用红黑树索引](#为何不用红黑树索引)
- [聚集索引和非聚集索引](#聚集索引和非聚集索引)
- [联合索引](#联合索引)

[4. 数据库三范式](#4. 数据库三范式)

[5. 几种数据库的对比](#5. 几种数据库的对比)

- [MySQL 和 Redis 的对比](#MySQL 和 Redis 的对比)
- [MongoDB](#MongoDB)





#### 1. 事务

数据库事务可以包含一个或多个数据库操作，但这些操作构成一个逻辑上的整体，要么全部执行成功,要么全部不执行。

##### ACID 特性

原子性（Atomicity）：事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。

一致性（Consistency）：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。

隔离性（Isolation）：并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。

持久性（Durability）：事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。

##### 常见的并发异常

脏写：事务回滚了其他事务对数据项的已提交修改；

脏读：一个事务读取了另一个事务未提交的数据；

丢失更新：事务覆盖了其他事务对数据的已提交修改,导致这些修改好像丢失了一样；

不可重复读：一个事务对同一数据的读取结果前后不一致，读取的是已提交的数据，但被其它事务修改过导致两次读取的结果不一致。

幻读：事务读取某个范围的数据时，因为其他事务的操作导致前后两次读取的结果不一致。

##### 事务的隔离级别

事务的隔离级别越低,可能出现的并发异常越多,但是通常而言系统能提供的并发能力越强。

| 隔离级别 | 脏写 | 脏读 | 丢失更新 | 不可重复读 | 幻读 |
| :------: | :--: | :--: | :------: | :--------: | :--: |
| 读未提交 |      |  √   |    √     |     √      |  √   |
| 读已提交 |      |      |    √     |     √      |  √   |
| 可重复读 |      |      |          |            |  √   |
|  串行化  |      |      |          |            |      |

##### 事务隔离性的实现

- 基于锁的并发控制：对于并发可能冲突的操作，通过加锁使其互斥执行。

  共享锁：一旦存在共享锁，其它事务只能在其之上再加共享锁，不能加排它锁；

  排它锁：一旦存在排它锁，任何事物不得再加锁。

  读申请共享锁，写申请排他锁。

- 基于时间戳的并发控制：对于并发可能冲突的操作，基于时间戳排序规则选定某事务继续执行，其他事务回滚。

- 基于有效性检查的并发控制：事务对数据的更新首先在自己的工作空间进行,等到要写回数据库时才进行有效性检查,对不符合要求的事务进行回滚。

- 基于快照隔离的并发控制：数据库为每个数据项维护多个版本(快照),每个事务只对属于自己的私有快照进行更新,在事务真正提交前进行有效性检查,使得事务正常提交更新或者失败回滚。

##### 日志恢复技术

- 撤销事务undo：将事务更新的所有数据项恢复为日志中的旧值，事务撤销完毕时将插入一条`<T abort>`记录。
- 重做事务redo：将事务更新的所有数据项恢复为日志中的新值。

事务正常回滚或事务因故障中止将进行redo，只重做已提交的事务；
系统从崩溃中恢复时将先redo重做所有事务，再undo回滚未提交的事务。

##### 检查点技术

系统保证在检查点之前已经提交的事务对数据库的修改已经写入磁盘,不需要进行redo。

系统崩溃时，先将日志记录中所有事务的更新按顺序重做一遍，再针对需要撤销的事务或未提交的事务按相反的顺序执行其更新操作的撤销操作。（先redo再undo）

![image-20220507222029896](https://s2.loli.net/2022/05/07/iBDb29tfelvxFuG.png)

#### 2. 数据库引擎

数据库引擎是用于存储、处理和保护数据的核心服务，利用数据库引擎可以控制访问权限并快速处理事务。

##### 数据库引擎的类型

- ###### InnoDB 引擎

  - ###### 缓存设计

    MySQL 中数据是存储在物理磁盘上的，而真正的数据处理又是在内存中执行的,由于磁盘的读写速度非常慢，InnoDB 将数据划分为若干页，以页作为磁盘与内存交互的基本单位，一般页的大小为16KB。如果一行数据太大分散在多页中，则在特定数据段索引溢出数据的存储页。

  - ###### LRU 淘汰策略

    InnoDB 对 LRU 做了优化，将 LRU 链表分成了 young 区（5/8）和 old 区（3/8），young 区存储使用频率非常高的缓存页，即热点数据，old 区存储用频率不是很高的缓存页，即冷数据。预读数据和全表扫描造成的命中只会放入到 old 区，只有真正使用 old 区的数据后才会将其加入 young 区。

  - ###### 自适应哈希索引

    对于缓冲池中的一些热点索引页，InnoDB 为了提高这些页的访问速度，会自动在缓冲池中建立一个自适应Hash索引。

  - ###### LogBuffer（Redo Log）

    InnoDB 对数据修改时，先将数据读到内存中，在内存中修改，为防止频繁磁盘 IO，MySQL 会将跟心先缓存在内存中，当服务器空闲时才将脏页刷新到磁盘中。为避免脏页落盘时系统崩溃造成数据丢失，InnoDB 会把对页面的修改操作同时写入一个日志文件持久化到磁盘上，这样 MySQL 崩溃重启后，会通过这个日志文件执行恢复操作，这个文件就是 Redo Log。

  - ###### 为何使用 Redo Log

    日志文件也是磁盘文件，为什么不直接更新到数据文件中，而是要先更新到redo log中呢？ 这是因为，写日志文件是顺序 IO，写数据是随机 IO，前者效率优于后者。

- ###### MyISAM 引擎

  MYISAM 是 MySQL 5.5- 使用的默认存储引擎，强调快速读取操作，并发效率高，但相应地数据恢复会比较困难。

- ###### MEMORY存储引擎

  MEMORY 存储引擎将表中的数据存储到内存中，为查询数据快速访问，它执行 HASH 索引和 B Tree 索引。

##### InnoDB 与 MyISAM 差别

- InnoDB 是 MYSQL 5.5+ 使用的默认存储引擎，MyISAM 是 MySQL 5.5- 使用的默认存储引擎；
- InnoDB 支持事务，MyISAM 不支持，InnoDB 把每一条 SQL 语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在 begin 和 commit 之间，组成一个事务；
- InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败； 
- InnoDB 是聚集索引，使用 B+ Tree 作为索引结构，主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值。MyISAM 是非聚集索引，其 B+ Tree 主键索引和辅助索引的叶子节点都是数据文件的地址指针。



#### 3. 索引

##### B树和B+树的区别

- 在B树中，将键值对存储在内部节点和叶结点，在B+树中，内部结点是键，叶结点存放键值对；
- B+树的叶结点有一条链相连接，而B树的叶结点各自独立；

##### 使用B树索引的好处

B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。

##### 使用B+树索引的好处

由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间。

##### 使用Hash索引的特点

hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。不支持模糊查询以及多列索引的最左前缀匹配。查询效率不稳定，可能频繁发生碰撞。

##### 为何不用B树索引

- B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
- 索引往往以索引文件的形式存储的磁盘上，B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了；
- 数据库中基于范围的查询是非常频繁的，B+树的查询效率更加稳定，随机检索时每一个关键字的查询效率相当，顺序查找时效率大幅提升；
- 内部结点空间小，增删结点时效率更高。

##### 为何不用AVL树索引

- 维护平衡过程的成本代价很高，因为每次删除一个节点或者增加一个节点的话，需要一次或者多次的左旋，右旋等去维护“平衡”状态；
- 查询的效率不稳定，还是会有看运气的成分在里面；
- 节点很多的话，AVL树的高度很高，查询效率低；
- 节点存储的数据内容太少。没有很好利用操作系统和磁盘数据交换特性，也没有利用好磁盘IO的预读能力。

##### 为何不用红黑树索引

- 树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况；
- 查询的效率不稳定，且不适合范围查询；
- 虽然增删结点的代价小于 AVL 树，但依然大大高于 B+ 树。

##### 聚集索引和非聚集索引

聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据，适合小数据；

非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，适合大数据。

##### 联合索引

使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。



#### 4. 数据库三范式

第一范式：列不可再分，每一列具有原子性

第二范式：属性完全依赖于主键，而不依赖于主键的一部分，消除部分依赖

第三范式：属性不依赖于其它非主属性，没有间接依赖于主键的列，消除传递依赖



#### 5. 几种数据库的对比

- ##### MySQL 和 Redis 的对比

  - ###### 类型

    MySQL 是关系型数据库，Redis 是缓存型数据库。

  - ###### 功能

    MySQL 用于持久化的存储数据到硬盘上，功能强大，读写速度慢但存储空间大，性价比高；Redis 在内存中作用，用于存储热点数据，读写速度快，但空间小。

  - ###### 需求

    一般来说二者都是搭配使用，需要高性能的地方用 Redis，不需要高性能的地方用 MySQL。

- ##### MongoDB

  - MongoDB 是一个基于分布式文件存储的数据库；
  - 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的；
  - MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成；
  - 在高负载的情况下，添加更多的节点，可以保证服务器性能。
  - 特性：使用键值对存储数据，不支持 ACID 特性，无事务处理，学习成本高。
