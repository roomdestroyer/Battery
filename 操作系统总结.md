## 操作系统知识点总结

[1. 进程](#1. 进程)

- [进程、线程、协程的区别](#进程、线程、协程的区别)
- [为什么切换虚拟地址空间比较耗时？](#为什么切换虚拟地址空间比较耗时？)
- [进程间的通信方式有哪些](#进程间的通信方式有哪些)
- [进程或线程间的同步方式](#进程或线程间的同步方式)

[2. 死锁](#2. 死锁)

- [](#)

[](#)

[](#)

[](#)

[](#)

[](#)

[](#)

[](#)

[](#)





### 1. 进程

- #### 进程、线程、协程的区别

  - ##### 调度

    进程是最小的资源分配和管理单元，线程是最小的程序执行单元，协程是线程抽象出来的轻量级执行单元，内核感知不到协程的存在，协程的调度完全由用户控制；

    进程和线程被内核控制，线程是被分割的 CPU 资源，协程是组织好的代码流，线程是协程的资源，但协程并不直接使用线程，而是利用执行器关联的线程池。

  - ##### 上下文切换

    进程在上下文切换时，需要存储和恢复 CPU 寄存器值、切换全局页表目录、切换内核栈；

    线程在上下文切换时，因为线程共享进程的虚拟地址空间和内核栈，所以只需要切换 CPU 上下文；

    协程不涉及上下文切换。

  - ##### 同步

    进程和线程都是同步机制，协程是异步机制。

- #### 为什么切换虚拟地址空间比较耗时？

  - TLB 中缓存着常用的地址映射关系，一旦页表发生切换，虚拟地址空间映射关系该表，TLB 几乎会全部失效，表现出来的程序执行速度就会变慢

- #### 进程间的通信方式有哪些

  - ##### 管道

    管道是半双工的，数据只能单向流动，只能承载无格式的字节流；

    匿名管道是单向的，只能在具有亲缘关系的进程间通信；

    命名管道以磁盘文件的方式存在，可以实现任意两个进程间的通信。

  - ##### 信号

    信号可以在任一时刻发给某一进程，而无需知道该进程的状态；

    如 Linux 中按 `Ctrl+C` 产生程序终止信号 `SIGINT`，执行`kill -9` 产生 `SIGKILL` 信号。

  - ##### 信号量

    信号量是一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，用于进程间或同一进程内不同线程间的同步手段。

  - ##### 消息队列

    消息队列是消息的链接表，进程可以向队列中添加消息，被赋予读权限的进程可以读走队列中的消息，消息队列承载的信息量多，可按格式传送，缓冲区大小不受限。

  - ##### 共享内存

    共享内存由一个进程创建，多个进程可以访问，它是最快的 IPC 方式，它是针对其它进程间通信方式运行效率低而专门设计的，往往与信号量配合使用来实现进程间同步互斥关系。

  - ##### Socket

    用于不同机器间的进程通信。

    - ###### 套接字定义

      ~~~
      Descriptor = socket(protofamily, type, protocol);
      ~~~

    - ###### BInd 过程

      套接字定义后，服务器使用 Bind 提供一个端口，服务器通过它等待通信

      ~~~
      Bind(socket, port);
      ~~~

    - ###### Listen 过程

      服务器调用 Listen 过程将套接字设为被动模式以使它用来等待客户请求

      ~~~
      Listen(socket, buffer_size);
      ~~~

    - ###### Connect 过程

      客户端与指定服务器建立连接

      ~~~
      Connect(socket, port);
      ~~~

    - ###### Accept 过程

      服务器接受客户的一个请求

      ~~~
      newsock = Accept(socket, port);
      ~~~

    - ###### Send 过程

      如果套接字已连接，send 可以用来传输数据

      ~~~
      Send(socket, data, length);
      ~~~

    - ###### Recv 过程

      一个应用可以用 Recv 语句接受消息

      ~~~
      Recv(socket, buffer, length);
      ~~~

    - ###### Close 过程

      关闭套接字

      ~~~
      Close(socket);
      ~~~

- #### 进程或线程间的同步方式

  - ##### 临界区

    通过对多线程的串行化来访问公共资源或一串代码，速度快。

    优点：保证某一时刻只有一个线程可以访问数据，控制逻辑简单；

    缺点：只能用来同步本进程内的线程，不可同步多个进程中的线程。

  - ##### 互斥量

    为协调对共享资源的访问而设计的，只有拥有互斥对象的线程才有权限访问资源。

    优点：可以在不同进程的线程之间实现对资源的安全共享；

    缺点：因为可以跨进程使用，所以所需要的资源就更多，并且它只是一种资源计数器，系统的并发性并不高。

  - ##### 信号量

    为提高系统并发访问资源而设计，允许多线程在某时刻按一定顺序或同时访问同一资源。

    优点：适用于 socket 程序中的线程同步，适合表达复杂的同步互斥逻辑；

    缺点：编程复杂，难以维护，且只适用于公共内存，不适用于分布式操作系统。

  - ##### 事件

    用来通知线程有一些事发生，从而启动后续任务开始，操作较简单，也比较安全。

  



### 2. 死锁

- #### 死锁发生的条件

  - ##### 互斥条件

    资源在一段时间内某资源仅能被一进程所占用。

  - ##### 请求和保持

    当进程因请求资源而阻塞时，对已获得的资源保持不放。

  - ##### 不可剥夺

    进程所占有的资源只能被自己用完而释放，不能被其它进程所剥夺。

  - ##### 环路等待

    在发生死锁时，必然存在一个进程间循环等待资源的环路。

- #### 解决死锁的方法

  - ##### 预防死锁

    - 要么不分配资源，要么一次性分配所有资源，破坏请求和保持条件；
    - 当进程获得了部分资源但得不到其它资源，则释放已占有的资源，破坏不可剥夺条件；
    - 统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反，破坏环路等待条件。

  - ##### 避免死锁

    - 银行家算法：系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。

  - ##### 检测死锁

    - 为每个进程和每个资源指定一个唯一的号码，建立资源分配表和进程等待表，实时检测有无环路。

  - ##### 接触死锁

    - 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
    - 撤销进程：可以直接撤消死锁进程，直至死锁状态消除为止。

  - 

