# 编译原理总结

## 一、简答与计算

### 1.1 必考

#### 1. 编译过程

- 画图表示编译过程的各阶段，并简要说明各阶段的功能：

<img src="https://s2.loli.net/2022/06/15/DZBR9igUQtoOWNM.jpg" alt="img" style="zoom: 50%;" />

- 词法分析器：输入源程序，进行词法分析，输出单词符号；
- 语法分析器：根据文法构建分析表，对单词符号进行语法分析，检查程序是否符合语法规则；
- 语义分析与中间代码生成器：按照文法翻译规则对语法分析器归约出的语法单位进行语义分析，并把它们翻译成一定形式的中间代码；
- 优化器：对中间代码进行优化处理；
- 目标代码生成器：把中间代码翻译成目标代码。

#### 2. 消除左递归

<img src="https://s2.loli.net/2022/06/16/wPDj4uKJbnlZHrA.png" alt="image-20220616162952878" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/06/16/QTCEwGJvjq5DXKn.png" alt="image-20220616163330803" style="zoom: 75%;" />

如果从开始符号依次推导出 A<sub>1</sub> A<sub>2</sub> A<sub>3</sub> ，则按其逆序排序时得到的产生式最少。

#### 3. 消除回溯

![image-20220620164318886](https://s2.loli.net/2022/06/20/BhmFZXgrio8zVU6.png)

通过反复提取左公因子可以消除回溯。

#### 4. 提左公因子

<img src="https://s2.loli.net/2022/06/16/naN5OZM4AHVxwGi.png" alt="image-20220616164716208"  />



#### 5. 后缀表达式

**中缀转后缀算法：**

初始化符号栈，顺序读取中缀表达式，遇到 `(` 则将其入栈，遇到 `)` 则依次弹出栈顶元素到结果串中，直到遇到 `(` ，将其出栈但不附加到结果串；

遇到 `+-`，弹出栈顶的所有操作符，附加到结果串中，然后自己进栈；

遇到 `*/`，先让栈顶的 `*/` 出栈，附加到结果串中，然后自己进栈；

遇到数字，直接附加到结果串中；

最后若符号栈非空，将符号栈栈顶元素依次附加到结果串中。

~~~
// 中缀转后缀
vector<string> interToPost(vector<string> vec)
{
	vector<string> res;
	stack<string> op_stack;
	for (int i = 0; i < vec.size(); i++) {
		if (vec[i] == "(")
			op_stack.push(vec[i]);
		else if (vec[i] == ")") {
			while (op_stack.top() != "(") {
				res.push_back(op_stack.top());
				op_stack.pop();
			}
			// 左括号出栈
			op_stack.pop(); 
		}
		// 遇到+-，先让栈中的+-*/出栈
		else if (vec[i] == "+" || vec[i] == "-") {
			while (!op_stack.empty() && op_stack.top() != "(") {
				res.push_back(op_stack.top());
				op_stack.pop();
			}
			op_stack.push(vec[i]);
		}
		// 遇到*/，先让栈中的*/出栈
		else if (vec[i] == "*" || vec[i] == "/") {
			while (!op_stack.empty() && (op_stack.top() == "*" || op_stack.top() == "/")) {
				res.push_back(op_stack.top());
				op_stack.pop();
			}
			op_stack.push(vec[i]);
		}
		else
			res.push_back(vec[i]);
	}
	while (!op_stack.empty()) {
		res.push_back(op_stack.top());
		op_stack.pop();
	}
	return res;
}
~~~

**计算后缀表达式：**

初始化数据栈，顺序读取后缀表达式，遇到操作符 `op` 则将栈次顶元素 `op` 栈顶元素，弹出操作数并压入运算结果；

遇到数据，则直接压入栈顶；

最终栈顶元素就是结果。

~~~
// 计算后缀表达式
double solvePostPrefix(vector<string> post_prefix) {
	stack<double> dataStack;
	double num1, num2, result;
	for (auto x : post_prefix) {
		if (x == "+" || x == "-" || x == "*" || x == "/") {
			num1 = dataStack.top();
			dataStack.pop();
			num2 = dataStack.top();
			dataStack.pop();
			if (x == "+")
				result = num2 + num1;
			if (x == "-")
				result = num2 - num1;
			if (x == "*")
				result = num2 * num1;
			if (x == "/")
				result = num2 / num1;
			dataStack.push(result);
		}
		else {
			double num = strToDouble(x);
			dataStack.push(num);
		}
	}
	return dataStack.top();
}
~~~



### 1.2 选考

#### 1. 编译、翻译和解释

- 翻译程序：把一种语言程序（源语言）转换成另一种语言程序（目标语言）；
- 编译程序：源语言为高级语言，目标语言为低级语言的翻译程序；
- 解释程序：以源语言作为输入，但不产生目标程序，而是边翻译边执行源程序本身。

#### 2. 中间代码

是一种含义明确、便于处理的记号系统，通常独立于具体的硬件但与指令形式有某种程度的接近，或者能够比较容易的转换为机器指令，常见的形式有：

- 三元式；
- 间接三元式；
- 四元式；
- 逆波兰式；
- 树形表示。

#### 3. 目标代码

把中间代码变换为特定机器上的低级语言代码，产生出足以发挥硬件效率的目标代码是一件非常不容易的事情。常见的形式有：

- 汇编指令代码：需要汇编才能执行；

- 绝对指令代码：可以立即执行；

- 可重定位指令代码：运行前必须借助于一个链接装配程序，把各个目标模块（包括系统提供的库模块）连接在一起，确定程序装入内存中的起始地址，使之成为一个可以运行的绝对指令代码程序。

  

#### 4. 属性文法

- S-属性文法：只含有综合属性的文法；
- L-属性文法：含有综合属性或继承属性，且改继承属性仅依赖于：
  - 产生式体该符号左边的那些属性；
  - 产生式头的继承属性；



#### 5. T 型图

![img](https://s2.loli.net/2022/06/20/pS3JNiusCVUw6L1.png)

#### 6. 高级语言的分类

- 强制式语言：面向底层和语句，每个语句的执行引起若干存储单元中值的改变；

- 应用式语言：更注重程序所表示的功能，每条语句都封装了复杂的功能；

- 基于规则的语言：检查一定的条件，当它满足值，则执行适当的动作；

- 面向对象的语言：主要特征是封装性、继承性、多态性。

  

#### 7. 闭包

用 Σ<sup>*</sup> 表示 Σ 上所有符号串的全体，空字 ε 也在其中，称为 Σ 的闭包。

- Σ = {a, b}，则 Σ<sup>*</sup> = {ε, a, b, aa, ab, bb, aaa, ...}。

  

#### 8. 上下文无关文法

![image-20220615185419507](https://s2.loli.net/2022/06/15/2pEMSWJKwiBrztf.png)



#### 9. 构造文法

<img src="https://s2.loli.net/2022/06/15/q6p8iloDwKOdxc9.png" alt="image-20220615192409498" style="zoom: 80%;" />

<img src="https://s2.loli.net/2022/06/16/6iRjxD8gUQsTPzr.png" alt="image-20220616111325547" style="zoom:80%;" />



#### 10. 二义文法

如果一个文法的某个句子对应两棵不同的语法树，即其最左（ 最右）推导不唯一，称该文法为二义文法。对程序设计语言来说，常常希望它的文法是无二义的，因为我们希望对它每个语句的分析是唯一的。

- 消除文法二义性的关键步骤：

  - 划分优先级和结合性；
  - 优先级高一级的运算，增加一层产生式；
  - 递归非终结符在左边，运算具有左结合性，否则具有右结合性。

- 例子：改写二义文法

  ~~~
  E -> E + E 
  E -> E * E
  E -> (E) | -E | id
  ~~~

  - 优先级从低到高： `[+]`；`[*]`；`[( ), -, id]`；

  - 结合性：

    左结合：`[+, *]`
    右结合：`[-]`
    无结合：`[id]`

  - 非终结符与运算：

    `E:+` （E产生式，左递归）
    `T:*` （T产生式，左递归）
    `F:-,( ),id` （F产生式，右递归）

  ~~~
  E → E + T | T
  T → T * F | F
  F → (E) | -E | id
  ~~~



#### 11. 构造正规式

![image-20220615203242446](https://s2.loli.net/2022/06/15/2UHNmyPTZxKhsdJ.png)



#### 12. DFA

![image-20220615203548406](https://s2.loli.net/2022/06/15/ohIKHxdzPWEpXOs.png)

- ##### 设计 DFA 例题

  ![image-20220615204549610](https://s2.loli.net/2022/06/15/doHGTOtCwQUpZiv.png)

  ![image-20220615204803833](https://s2.loli.net/2022/06/15/HpP9mVRgeIzSnyw.png)

  ![image-20220615204844463](https://s2.loli.net/2022/06/15/8Ss4ARUKeqvMjur.png)

  

#### 13. NFA

![](https://s2.loli.net/2022/06/15/19XIOtiGHqAmoSv.png)

- ##### 构造 NFA 例题

  ![image-20220615215948007](https://s2.loli.net/2022/06/15/jR8ZBsgfJ9qvAdy.png)



#### 14. 句柄

**句型：**从文法开始符号推导出来的任一文法符号串；

**句子：**从文法开始符号推导出来的任一终结符号串；

**短语：**对文法 `G[S]`，如果有 `S =>* αAδ` 且 `A =>+ β`，则称 `β` 是句型 `αAδ` 相对于非终结符号 `A` 的短语。

> 短语是语法树中所有子树的边缘，是相对于子树根节点的短语。

例如：

<img src="https://s2.loli.net/2022/06/16/Cnp2xzaS6bYLJjQ.png" alt="image-20220616224920733" style="zoom:80%;" />

短语是 `S`，`(T)`，`Sd(T)`，`b`，`Sd(T)db`，`(Sd(T)db)`；

**直接短语：**对文法 `G[S]`，如果有 `S =>* αAδ` 且 `A => β`，则称 `β` 是句型 `αAδ` 相对于非终结符号 `A` 的短语。

> 直接断语是所有二层子树的边缘，在上图中只有三个二层子树。

例如：上图的直接短语是  `S`，`(T)`，`b`；

**句柄：**最左直接短语；

> 句柄是最左二层子树的边缘。

例如：上图的句柄是 `S`；

**素短语：**至少包含一个终结符的短语，并且除它自身之外不再包含其他素短语；

例如：上图的素短语是 `(T)`，`b`；

**最左素短语：**句型最左边的素短语，是算符优先分析法的规约对象；

例如：上图的最左素短语是 `(T)`；

**例子：**

![image-20220616225710296](https://s2.loli.net/2022/06/16/Mjw9iBYrpG6XZJf.png)

![image-20220616225718632](https://s2.loli.net/2022/06/16/8Vtnl4OGwLNr5BQ.png)

**活前缀：**是句型的一个前缀，不含句柄以后的任何符号；

**例子：**

<img src="https://s2.loli.net/2022/06/16/87hbM1VOcXf4QsP.png" alt="image-20220616235229778" style="zoom:80%;" />

#### 15. 规范规约

规范规约是最右推导的逆过程，因此也称为最左规约。

<img src="https://s2.loli.net/2022/06/16/vaiLnfPe5xruQ2q.png" alt="image-20220616231023848" style="zoom:80%;" />



#### 16. 根据 FA 写正规式

是根据正规式构造 FA 的逆过程。



#### 17. 符号表

用于登记源程序的各类信息，如变量名、常量名、过程名等，以及编译各阶段的进展状况。当扫描器识别出一个标识符后，把该名字填入符号表，在语义分析阶段回填类型，在目标代码生成阶段回填地址。

**符号表的作用和地位：**（重点）

- 收集符号属性；
- 语义合法性检查的依据，如重复变量定义；
- 作为目标代码生成阶段地址分配的依据。

**符号表的主要属性：**

- 符号名：变量、过程、类的名称；
- 符号数据类型：整型、实型、布尔型；
- 符号声明类别：`static` 、`const` 等；
- 符号存储方式：堆区存储还是栈区存储等；
- 符号作用域：全局变量与局部变量；

**符号表的组织方式：**

- 构造多个符号表，具有相同属性种类的符号组织在一起；
- 把所有符号项都组织在一张大的符号表中；
- 折中了上述两种方案，根据符号属性的相似程度分类成若干张表；
- 使用对象组织，需要编译器的支持，但非常方便管理；

**符号表项的排列：**

- 数组：线性组织；
- 链表：`Hash` 表，跳表；
- 树形：二叉树，平衡二叉树。

#### 18. 运行时空间组织

**运行时存储器的划分**：

- 代码区：编译生成的目标代码；
- 静态区：编译时就可以完全确定的数据；
- 栈区：栈式内存分配；
- 堆区：堆式内存分配；

**存储分配策略：**

- **静态分配策略：**在编译时对所有数据对象分配固定的存储单元，且在运行时始终保持不变；
- **栈式动态分配策略：**在运行时把存储器作为一个栈进行管理，运行时，每当调用一个过程，它所需要的存储空间就动态地分配于栈顶，一旦退出，它所占空间就予以释放；
- **堆式动态分配策略：**在运行时把存储器组织成堆结构，以便用户关于存储空间的申请与归还（回收），凡申请者从堆中分给一块，凡释放者退回给堆；

**活动记录**：

为了管理过程在一次执行中所需要的信息，使用一个连续的存储块，这样的一个连续存储块称为活动记录， 一般包括：

- 局部变量：源代码中在过程体中声明的变量；
- 临时单元：为了满足表达式计算要求而不得不预留的临时变量；
- 内情向量：内情向量是静态数组的特征信息，用来描述数组属性信息的一些常量，包括数组类型、维数、各维的上下界及数组首地址；
- 返回地址：调用位置的地址；
- 动态链：`SP` 指向当前过程的动态链地址（也是帧起始地址），它又指向调用该过程的上一过程的帧起始地址，用于过程结束后回收分配的帧；它和函数的嵌套定义关系无关，只与调用顺序有关；
- 静态链：指向当前过程的直接父过程的帧起始地址，用于访问非局部数据，它只与函数嵌套定义关系有关。

![image-20220618015919118](https://s2.loli.net/2022/06/18/1MSUvjkysEa2PKo.png)



#### 19. 优化手段

- 源代码级别：选择适当的算法，例如快排优于插排；
- 语义动作级别：生成高效的中间代码，例如在词法分析阶段加入错误检查；
- 中间代码级别：安排专门的优化阶段，例如 `DAG` 优化；
  - 局部优化：例如 `DAG `优化；
  - 循环优化：包含代码外提、强度削弱、删除归纳变量、复写传播等；
- 目标代码级别：考虑如何有效地利用寄存器，例如窥孔优化。



#### 20. 待用/活跃信息

当翻译 `A = B op C` 时：

- **待用信息：**变量在哪些中间代码中还会被**引用**；
- **活跃信息：**`A`、`B`、`C` 是否还会在基本块内被**引用**；

![image-20220618185515068](https://s2.loli.net/2022/06/18/fM5xTWrs9c6OSVy.png)



#### 21. LL(1)分析

对于一个不含回溯和左递归的文法，LL(1) 方法从左到右扫描输入串，维护一个状态栈和一个符号栈，每一步只向右查看一个符号，根据状态栈顶、符号栈顶和分析表的内容来确定下一步的动作，最终分析出整个句子。



#### 22. LR(1)分析

LR(1) 分析适合大多数上下文无关文法，它从左到右扫描符号串，能记住移进和规约出的整个符号串，即 “记住历史”，还可以根据所用的产生式推测未来可能碰到的输入符号，即 “展望未来”，根据 “历史”、“展望” 和分析表的内容来确定下一步的动作，最终分析出整个句子。



#### 23. display 表

为提高访问非局部变量的速度，引入指针数组指向本过程的所有外层，成为嵌套层次显示表，display 表是一个栈，自顶向下依次指向当前层、直接外层、直接外层的直接外层，直到最外层。



#### 24. 语法制导翻译法

对单词符号串进行语法分析，构造语法分析树，然后根据需要遍历语法树并在语法树的各结点处按语义规则进行计算。这种有源程序的语法结构驱动的处理办法就是语法制导翻译法。



## 二、综合题

### 2.1 词法分析

> 给定正规式： ①构造NFA  ②确定化 ③最小化

#### 例题

① + ② 

![image-20220615220445134](https://s2.loli.net/2022/06/15/siIOZQxtPejAUDM.png)

③

![image-20220615221745695](https://s2.loli.net/2022/06/15/Sro7TIPwC2ZRqQf.png)





![image-20220615222334279](https://s2.loli.net/2022/06/15/pdyHJwGZD8XmacF.png)



### 2.2 LL(1) 分析

> 给出文法：①构造First集合 ②构造Follow集合 ③构造LL(1)分析表 ④识别句子

#### 例题

##### 前提：LL(1) 适用条件

![image-20220616165155939](https://s2.loli.net/2022/06/16/N5MbtJmdlHWR3ge.png)

##### ①求 `First(X)`

![image-20220616165438384](https://s2.loli.net/2022/06/16/bhgDmRYqr456EWS.png)

>A -> Bc                                                                                                                            
>
>B -> ε
>
>则 First(A) = { c }；
>
>若 A -> B 
>
>B -> ε
>
>则 First(A) = { ε }；

##### ②求 `Follow(X)`

![image-20220616171358707](https://s2.loli.net/2022/06/16/iSY1Ldcye6gQ8OK.png)

##### ③构造分析表

![image-20220616173215360](https://s2.loli.net/2022/06/16/bKZLeEAtR9l2riY.png)

![image-20220616173408649](https://s2.loli.net/2022/06/16/BlZAFbM3s9ptCOi.png)

##### ④分析过程

![image-20220616175857393](https://s2.loli.net/2022/06/16/PrL8sAWGd1KXCFV.png)

![image-20220616175908255](https://s2.loli.net/2022/06/16/rPNZaSvKi2smhDO.png)





### 2.3 LR(1) 分析

> 给出文法：①构造拓广文法 ②求First集合 ③构造LR(1)项目集规范族 ④构造LR(1)分析表并消除二义性 ⑤识别句子

构造带向前搜索符的DFA，无归约-归约冲突则是LR(1)文法。

#### 例题1

~~~
构造文法G[S]的LR(1)项目集规范族：
S -> aCaCb
S -> aDb
C -> a
D -> a
~~~

##### ①构造拓广文法：

~~~
S' -> S
S -> aCaCb
S -> aDb
C -> a
D -> a
~~~

##### ②求 `First` 集合：

![image-20220617015244163](https://s2.loli.net/2022/06/17/NqK4YgIQOnZDG7x.png)

##### ③构造 `LR(1)` 项目集规范族：

![image-20220617015341765](https://s2.loli.net/2022/06/17/GXzMBeTYmQIsVtc.png)

##### ④构造 `LR(1)` 分析表并消除二义性：

![](https://s2.loli.net/2022/06/17/8POtzly5ks4jvUf.png)

> 消除二义性需要认为定义运算优先级，发生移入-规约冲突时选择正确的项填入。

##### ⑤识别句子 `aaaab` 和 `aab` ：

![image-20220617015635034](https://s2.loli.net/2022/06/17/vaH1pqTJ6XsybUn.png)



#### 例题2

对下列文法做 LR(1) ：

~~~
S -> AS | b
A -> SA | a
~~~

![img](https://s2.loli.net/2022/06/20/ONgSY5PaoUjLzpX.jpg)

![](https://s2.loli.net/2022/06/20/izbACSoNOIPe8hs.jpg)

![](https://s2.loli.net/2022/06/20/izbACSoNOIPe8hs.jpg)



### 2.4 中间代码生成

> 给出翻译模式和高级语言程序，翻译句子，一般涉及多种类型句子的综合，也可能涉及声明语句填写符号表。

#### 1. 过程中的说明语句

<img src="https://s2.loli.net/2022/06/17/QwheYrpCT73XPxo.jpg" alt="img" style="zoom: 45%;" />

<img src="https://s2.loli.net/2022/06/17/Y9ocbNMQOVd81gP.jpg" alt="img" style="zoom:50%;" />

![image-20220617171901490](https://s2.loli.net/2022/06/17/ZKoWt7aUJvFRwfI.png)



#### 2.算术表达式的翻译

<img src="https://s2.loli.net/2022/06/17/7fxDLR19gZhIOX4.png" alt="image-20220617171233909"  />

<img src="https://s2.loli.net/2022/06/17/TQKoLRpxZVMB5mz.png" alt="image-20220617171306138" style="zoom:90%;" />

<img src="https://s2.loli.net/2022/06/17/5XeyJDHEuwNMPvq.png" alt="image-20220617172649169"  />



#### 3. 布尔表达式的翻译

> 重点：回填。

<img src="https://s2.loli.net/2022/06/17/JSinUwhXaA5GTLo.png" alt="image-20220617204129295"  />

![image-20220617203954441](https://s2.loli.net/2022/06/17/YzKWv3ZbnPr1Uot.png)



#### 4. 控制流语句的翻译

> 重点：if 和 while 。

<img src="https://s2.loli.net/2022/06/17/SPt3N46mRqdD5xM.png" alt="image-20220617210312858"  />

![image-20220617214337930](https://s2.loli.net/2022/06/17/k1uBEzIfU7SWePO.png)

![image-20220617214400974](https://s2.loli.net/2022/06/17/AFvoImYJ1qXe2Gk.png)





### 2.5 目标代码生成

> 给出基本块代码：①构造DAG ②写出优化后的中间代码 ③写出DAG目标优化后的中间代码 ④根据变量活跃性和寄存器信息，写出目标代码。

#### 例题1

给出基本块代码为：

![image-20220618174837303](https://s2.loli.net/2022/06/18/Ffx4YIqBaeWJsrZ.png)

##### ①构造DAG

![image-20220618174926596](https://s2.loli.net/2022/06/18/oQnsZSyWOAXTMEH.png)

##### ②写出优化后的中间代码

![image-20220618174945854](https://s2.loli.net/2022/06/18/h5u2AZbnYUrc9RL.png)

##### ③写出DAG目标优化后的中间代码

~~~
(1) T6 = R - r
(2) T2 = R * r
(3) T4 = T2
(4) T1 = 6.28
(5) T3 = 6.28
(6) A = 6.28 * T2
(7) T5 = A
(8) B = A * T6
(9) T0 = 3.14
~~~



##### ④根据变量活跃性和寄存器信息，写出目标代码

假定 `B` 是基本块出口之后活跃的，有寄存器 `R0` 和 `R1` 可用，目标代码为：

> DAG 优化中，不活跃变量，目标代码依然要生成计算其值的代码，只是不生成存储到主存的代码。计算代码被优化是后续优化完成的，不是 DAG 完成的。

~~~
LD R0, R
SUB R0, r          R0: T6     R1: \
LD R1, R
MUL R1, r          R0: T6     R1: T2
ST R0, T6
LD R0, 6.28        R0: 6.28   R1: T2
MUL R0, R1         R0: A      R1: T2
MUL R0, T6         R0: B      R1: T2
ST R0, B
~~~
