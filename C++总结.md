# C++知识点总结

#### 目录

[1. C++ STL 底层数据结构是什么实现的](#C++ STL 底层数据结构是什么实现的)

[2. vector 扩容规则](#vector 扩容规则)

[3. static 关键字](#static 关键字)

[4. 智能指针](#智能指针)

- [代码实现](#智能指针代码实现)

[5. 如何判断机器是大端编码还是小端编码](#如何判断机器是大端编码还是小端编码)

[6. C++内存堆栈](#C++内存堆栈)

[7. C++ 代码的编译过程](#C++ 代码的编译过程)

[8. C++ 代码优化手段](#C++ 代码优化手段)

[9. 多态](#多态)

[10. 虚函数](#虚函数)

[11. 排序算法](#排序算法)

- [快排代码](#快排代码)

[12. 浅拷贝和深拷贝](#浅拷贝和深拷贝)

[13. 左值和右值](#左值和右值)

[14. new 空间时的详细过程](#new 空间时的详细过程)

[15. new 和 malloc 的区别](#new 和 malloc 的区别)

[16. 变量初始化顺序](#变量初始化顺序)

[17. C++ 执行 main 之前的操作](#C++ 执行 main 之前的操作)

[18. 为什么堆比栈快](#为什么堆比栈快)

[19. 变量的声明和定义有什么区别](#变量的声明和定义有什么区别)

[20. 设置地址初值](#设置地址初值)

[21. 拷贝构造函数和赋值构造函数的区别](#拷贝构造函数和赋值构造函数的区别)

[22. 一趟翻转链表](#一趟翻转链表)

- [代码](#一趟翻转链表)

[23. 两个栈实现一个队列](#两个栈实现一个队列)

[24. typedef 和 define 的区别](#typedef 和 define 的区别)

[25. 类型转换](#类型转换)



#### 正文

1. #### C++ STL 底层数据结构是什么实现的

   |    数据结构    |        底层实现         |
   | :------------: | :---------------------: |
   |      map       |         红黑树          |
   |      set       |         红黑树          |
   |     vector     |        动态数组         |
   |      list      |        双向链表         |
   |     stack      | list 或 deque，封闭头部 |
   |     deque      |    多个数组构成链表     |
   |     queue      | list 或 deque，封闭头部 |
   | priority_queue |         vector          |

2. #### vector 扩容规则

   当我们**新建**⼀个vector的时候，会⾸先分配给他⼀⽚连续的内存空间；

   向 vector 中添加元素时，如果初始分配空间已满，⾸先重新申请⼀个2倍⼤的内存空间；然后将原空间的内容拷贝过来，最后将原空间内容进⾏释放。

   当通过 **push_back** 向其中增加元素时，根据传入的参数生成一个临时对象，然后将临时对象拷贝到数组中，最后析构临时变量；

   当通过 **emplace_back** 向其中增加元素时，直接调用构造函数在数组末尾构造一个对象；

   emplace_back 大部分时候可以替代 push_back，效率更高，但当涉及到资源管理对象的容器，例如智能指针时，如果 emplace_back(new Obj) 时发生异常（例如空间不够），则管理对象的指针无效，且新分配的内存也泄露，但如果使用 push_back(new Obj)，发生异常时有一块临时空间管理内存，地址不会泄露。

3. #### static 关键字

   - **函数中的静态变量：**在函数内部使用静态变量时，仅初始化一次，然后通过函数调用，它们保留上次调用的结果值。
   - **静态类对象：**一经分配，直到程序结束才析构。
   - **类中静态变量：**类静态成员变量被所有的类对象所共享，必须在类外显式初始化。
   - **类中静态方法：**这些方法适用于整个类，而非某个对象，可以用类名来调用它。
   - C 语言中只有静态变量，C++ 中引入了静态成员和静态函数。

4. #### 智能指针

   ##### 智能指针基础概念

   为了更加容易（更加安全）的使用动态内存，引入了智能指针，智能指针的行为类似常规指针，重要的是它负责自动释放所指向的对象。

   - **shared_ptr：**多个shared_ptr指向同一处资源，当所有shared_ptr都全部释放时，该处资源才释放。
   - **unique_ptr：**一个指针独占所指对象，不允许赋值操作。

   ##### 智能指针代码实现

   ~~~
   #include <iostream>
   #include <mutex>
   using namespace std;
   
   // 模拟实现智能指针
   template <class T>
   class smart_ptr
   {
   private:
   	mutex mtx;
   	unsigned* cnt;
   	T* smart_p;
   public:
   	// 默认构造函数
   	smart_ptr()
   	{
   		smart_p = nullptr;
   		cnt = new unsigned(1);
   	}
   	// 构造函数
   	smart_ptr(T* p)
   	{
   		smart_p = p;
   		cnt = new unsigned(1);
   	}
   	// 复制构造函数
   	smart_ptr(const smart_ptr& rhs)
   	{
   		mtx.lock();
   		this->smart_p = rhs.smart_p;
   		this->cnt = rhs.cnt;
   		(*cnt)++;
   		mtx.unlock();
   	}
   	// 赋值构造函数
   	smart_ptr& operator=(const smart_ptr& rhs)
   	{
   		mtx.lock();
   		// 递增右侧运算对象的引用计数
   		++(*rhs.cnt);
   		// 释放本对象所指的空间，如果本对象是最后一个，则释放内存
   		if (--(*cnt) == 0)
   		{
   			delete smart_p;
   			delete cnt;
   			smart_p = nullptr;
   			cnt = nullptr;
   		}
   		// 赋值
   		cnt = rhs.cnt;
   		smart_p = rhs.smart_p;
   		mtx.unlock();
   		// 返回本对象
   		return *this;
   	}
   	// 获取指针
   	T* operator->() const
   	{
   		return smart_p;
   	}
   	// 获取指针值
   	T& operator*() const
   	{
   		return *smart_p;
   	}
   	// 析构函数
   	~smart_ptr()
   	{
   		mtx.lock();
   		if (--(*cnt) == 0)
   		{
   			delete smart_p;
   			delete cnt;
   			smart_p = nullptr;
   			cnt = nullptr;
   		}
   		mtx.unlock();
   	}
   	// 获取计数器
   	unsigned* getcnt()
   	{
   		return cnt;
   	}
   };
   
   struct MyStruct
   {
   	MyStruct(int a, int b) :a(a), b(b) {}
   	int a;
   	int b;
   };
   
   int main()
   {
   	MyStruct* s = new MyStruct(10, 20);
   
   	smart_ptr<MyStruct> sp1(s);
   
   	cout << "sp1->a:   " << sp1->a << endl;
   	cout << "sp1->b:   " << sp1->b << endl;
   	cout << "*(sp1).a: " << (*sp1).a << endl << endl;
   
   	auto sp2 = sp1;
   	cout << "sp2->a:   " << sp2->a << endl;
   	cout << "sp2->b:   " << sp2->b << endl;
   	cout << "*(sp2).a: " << (*sp2).a << endl << endl;
   
   	cout << "sp1->getcnt():  " << *sp1.getcnt() << endl;
   	cout << "sp2->getcnt():  " << *sp2.getcnt() << endl;
   	sp1.~smart_ptr();
   	cout << "sp1->getcnt():  " << *sp1.getcnt() << endl;
   	cout << "sp2->getcnt():  " << *sp2.getcnt() << endl;
   
   	return 0;
   }
   ~~~

5. #### 如何判断机器是大端编码还是小端编码

   ~~~
   #include <iostream>
   using namespace std;
   
   int main()
   {
   	// 低地址  --->  高地址
   	int a = 1;
   	// 大端：0x00000001  小端：0x01000000
   	char pa = *(char*)(&a);
   	// 强转为 char* 后，保留低地址的 1 个字节
   	// 大端：0x00        小端：0x01
   	cout << (pa == 1 ? "小端" : "大端") << endl;
   
   	return 0;
   }
   ~~~

6. #### C++内存堆栈

   在C++中，内存分成3个区，他们分别是堆，栈，静态存储区。

   - **堆：**内存使用 new 进行分配，使用 delete 释放，若未释放，可能导致内存泄漏，但在程序结束时，会由操作系统自动回收；
   - **栈：**内存由编译器自动分配和释放，用于存储局部变量和函数传参，效率高但容量小；
   - **静态存储区：**内存在程序编译的时候就已经分配好，在程序整个周期都存在，主要存放静态数据、全局数据和常量。

7. #### C++ 代码的编译过程

   - ##### 编译

     读取源程序字符流，对其进行词法分析和语法分析，将高级语言转为汇编代码。

     - **编译预处理：**读取 C 源程序，对其中的伪指令和特殊符号进行处理
       - 对 #define 宏定义指令进行字符替换；
       - 根据条件编译指令 #ifdef 等将不需要的编译的代码过滤掉；
       - 根据 #include 将包含的文件加入编译对象中；
       - 替换特殊符号为编译器可识别的符号。
     - **编译优化阶段：**经过词法分析和语法分析，确认所有指令都符号语法规则后，将其等价翻译为中间代码表示或汇编代码。
       - 中间代码优化：删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播、无用赋值的删除等；
       - 目标代码优化：与机器硬件密切相关，主要是考虑如何充分利用机器的各个硬件寄存器存放有关变量的值，以减少访存次数，另外根据机器流水线对指令顺序做一些调整以使性能最高。

   - ##### 汇编
     
     把汇编语言代码翻译成目标机器指令， 目标文件由段组成。通常一个目标文件中至少有两个段：
     
     - **代码段：**该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。
     - **数据段：**主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。
     
   - ##### 链接
     
     由汇编程序生成的目标文件并不能立即就被执行，链接程序将相互包含的文件彼此链接，使得所有目标文件成为一个可运行的整体。
     
     - **静态链接：**将程序涉及到的所有代码链接成一个整体去执行，浪费空间，节省时间；
     - **动态链接：**程序按模块划分，将索引存储在动态链接库中，在程序运行时才根据索引重定位到模块位置，并把它们连在一起形成一个完整的程序，节省空间，时间稍慢。

8. #### C++ 代码优化手段

   ##### 代码优化

   - 使用 scanf 和 printf 而不是 cin 和 cout；

   - 使用 getchar() 读入字符，然后再转为数字，利用 putchar() 将数字分割成字符输出；

   - 尽量减少值传递，多使用引用传参，尽量减少函数传参个数；

   - 对于操作简单、频繁使用的函数，声明为内联函数，这样在预编译时可以进行优化；

   - 少部分频繁使用的局部变量，将其放入寄存器中，加快变量调用；

   - 乘 2 操作改为左移，除以 2 操作改为右移，判断奇偶性时将其 & 1，以及以下操作：

     判断一个数的奇偶性：

     ~~~
     return (n & 1) == 1;
     ~~~

     取绝对值：

     ~~~
     return (n ^ (n >> 31)) - (n >> 31);
     ~~~

     取 max：

     ~~~
     return b & ((a - b) >> 31) | a & (~(a - b) >> 31);
     ~~~

     判断符号是否相同：

     ~~~
     return (x ^ y) >= 0;
     ~~~

     判断一个数是不是 2 的幂：

     ~~~
     return n > 0 ? (n & (n - 1)) == 0 : false;
     ~~~

     求两个整数的平均值：

     ~~~
     return (x + y) >> 1; 
     ~~~

   - 尽量使用三目运算符；

   - 尽量将 if else 语句改为 switch，减少汇编产生的跳转指令；

   - 二维数组尽量按行索引；

   - 定义类对象时尽量使用复制构造函数，而不是赋值构造函数；

   - 构造时使用参数列表初始化，而不是函数定义初始化；

   - 对于类，尽量使用 += 等二元运算符，而不是 + = 等一元运算符，避免中间临时对象生成；对于基本数据类型，尽量使用一元运算符，而少使用二元运算符；

   - 如果不是必须，不要使用模板库，编译 STL 会很慢；

   - 使用右值引用。

   ##### 编译时中间代码优化

   - 删除公共子表达式：若一个表达式的值在之前已经计算过，并且这之后变量的值并未改变，则可以删除对它的重复计算；
   - 复写传播：某些变量的值并未改变过就将其传递给其它变量，则可以直接引用原值本身；
   - 删除无用代码：一部分代码对程序整体执行结果并不影响，则可以删除它们；
   - 代码外提：对于循环中的某些代码，若循环中其值不变，就可以将它们提到循环外；
   - 强度削弱：若循环次数与变量的值存在线性关系，则可以在循环结束后统一计算其值，而不需在循环中逐步计算其值。

9. #### 多态

   ##### 静态多态

   基于模板可以实现静态多态，在编译时完成，执行时间快，且通过模板编程为 C++ 带来了泛型设计的概念，比如强大的 STL 库，但编译时花费时间高，调试困难。

   ##### 动态多态

   基于虚函数可以实现动态多态，在程序运行时完成，实现接口分离，丰富了面向对象编程的概念，编译时间快但执行速度较慢。

10. #### 虚函数

    - ##### 虚函数表

      虚函数表在编译时生成，是一片连续的静态区域，每个内存单元存放着 JMP 指令地址，派生类会拷贝基类的虚函数表到另一片内存区域中。

    - ##### 虚函数指针

      虚函数指针在运行时生成。在声明了一个虚函数类对象的同时，此对象被添加了一个隐式成员。该成员保存了指向虚函数地址数组的指针。一个类有多个对象时，所有对象共享一个虚函数表。

    - ##### 虚函数指针大小

      32 位机为 4 字节，64 位机为 8 字节；

    - ##### 虚函数重写

      派生类中有与基类完全相同的虚函数时，子类虚函数重写了基类的虚函数；

    - ##### 析构函数的重写

      如果基类的析构函数为虚函数，此时派生类析构函数一定重写基类虚析构函数；析构函数最好定义为虚函数，这样派生类析构时会递归释放所有空间。

    - ##### 纯虚函数

      在虚函数的后面加上 = 0，则函数称为纯虚函数，包含纯虚函数的类叫做抽象类，抽象类不能实例化对象，派生类只有重写纯虚函数后，才能实例化对象。

    - ##### 菱形继承

      导致数据拥有两份，资源浪费，可以用虚继承解决，只保留一份数据。

11. #### 排序算法

    |   算法   | 时间复杂度 | 最坏  | 最好  | 空间复杂度 | 稳定性 |
    | :------: | :--------: | :---: | :---: | :--------: | :----: |
    | 插入排序 |    n^2^    | n^2^  |   n   |     1      |   √    |
    | 冒泡排序 |    n^2^    | n^2^  |   n   |     1      |   √    |
    | 选择排序 |    n^2^    | n^2^  | n^2^  |     1      |   ×    |
    | 快速排序 |   nlogn    | n^2^  | nlogn |    logn    |   ×    |
    | 归并排序 |   nlogn    | nlogn | nlogn |     n      |   √    |
    | 计数排序 |   n + k    | n + k | n + k |   n + k    |   √    |
    | 基数排序 |   n * k    | n * k | n * k |   n + k    |   √    |
    | 希尔排序 |   n^1.3^   | n^2^  |   n   |     1      |   ×    |
    |  堆排序  |   nlogn    | nlogn | nlogn |     1      |   ×    |
    |  桶排序  |   n + k    | n^2^  |   n   |   n + k    |   √    |

    **堆排序的实现思路：** 将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

    **快速排序最差情况：**快排的运行时间依赖于划分是否平衡，当每次选取的主元素为最小元素或最大元素时，每次选择主元素时尽量随机化可以避免。

    **快排和堆排的比较：**虽然堆排最坏情况优于快排，但堆排序的常数较大，例如快排的复杂度是 O(1.39nlogn)，堆排的复杂度是 O(1.88nlogn)，总体来说快排更优。

    **STL sort 快排优化：**

    - 当数据量较大时采用快速排序，一旦分段后的数据量小于某个阀值，便会改用插入排序；
    - 如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。

    **比快排更快的算法：**

    - 桶排序：虽然桶排序时间复杂度能达到O(n+k)，但是它对要排序的数据要求非常严格
      - 要排序的数据需要很容易地**均匀划分**到 k 个桶中，且桶与桶之间有着天然的大小顺序。数据只需要在桶内进行排序后，数据总体就已经有序了。
      - 在极端情况下，所有的数据都划分到同一个桶内，那就退化为O(NlogN)时间复杂度的排序算法了。
    - 基数排序：空间复杂度比较高，需要额外开销大。排序有两个数组空间开销，一个存放待排序数组，一个就是所谓的桶，且待排序的元素都要在一定范围内。
    - 计数排序： 计数排序空间复杂度较高，只能适用于数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。

    ##### 快排代码

    ~~~
    #include <iostream> 
    using namespace std;
    
    void QuickSort(int* array, int low, int high) 
    {
    	if (low >= high)
    		return;
    	int i = low, j = high;
    	int key = array[low];
    	while (i < j) {
    		while (array[j] >= key && i < j) 
    			j--; 
    		array[i] = array[j];
    		while (array[i] <= key && i < j)	
    			i++;
    		array[j] = array[i];
    	}
    	array[i] = key;
    	QuickSort(array, low, i - 1);
    	QuickSort(array, i + 1, high);
    }
    int main() 
    {
    	int array[] = { 49,38,65,97,76,13,27,49 };
    	int length = sizeof(array) / sizeof(*array);
    
    	cout << "原始序列：";
    	for (int i = 0; i < length; i++)
    		cout << array[i] << " ";
    	cout << endl;
    
    	QuickSort(array, 0, length - 1);
    	cout << "快排序列：";
    	for (int i = 0; i < length; i++) 
    		cout << array[i] << " ";
    	
    	return 0;
    }
    ~~~

12. #### 浅拷贝和深拷贝

    - **浅拷贝：**在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。
    - **深拷贝：**深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

13. #### 左值和右值

    C++11 中所有的值都是左值、右值之一，右值又分为纯右值、将亡值。

    - **左值：**可以取地址、有名字的就是左值，如定义的变量、对象；
    - **右值：**在寄存器中，不能取地址、没有名字的就是右值，如运算中间结果、函数返回值。
      - **纯右值：**纯字面值，或由表达式计算产生的字面值；
      - **将亡值：**通过移动构造其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，来延长变量值的生命期。
      - **右值引用：**右值引用是临时变量的引用，可以解决复制是临时变量的构造与析构的开销，一个右值引用可能是左值也可能是右值，取决于它与左值还是右值所关联。
      - 能否定义一个右值，取决于表达式是否产生中间变量。
    - **移动语义：**进行赋值操作时，将资源的所有权从一个对象转移到另一个对象上，并没有内存的拷贝，从而解决了临时变量拷贝构造产生的性能损失的问题。
    - **完美转发：**在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。

14. #### new 空间时的详细过程

    - new 的底层是通过一个 while 循环用 malloc 进行内存申请，若申请不到就抛出异常；一个程序最多能 new **2^63^ -1 个单位的虚拟内存**，**实际能使用的内存取决于运行时操作系统给程序分配的堆区空间有多少。**
    - malloc 当申请小于 128KB 的内存时会调用 brk() 函数分配内存，当申请大于 128KB 的内存时调用 mmap() 函数分配内存；
    - **brk()** 直接在进程堆中分配，分配的内存只能从高到低释放，brk 指针只有一个，如果先开辟的内存空间释放了，那么那块内存会空在那里，如果此时有一个申请同样大小内存的请求，就可以复用，不然就是碎片一直在那里，产生内存碎片；
    - **mmap()** 在进程的虚拟地址空间中找一块空闲区，建立虚拟内存与物理内存的映射表，释放时可以很方便地释放，不改变进程的堆顶指针。

15. #### new 和 malloc 的区别

    - new 的底层调用 malloc；
    - new、delete 是操作符，可以重载，只能在 C++中使用；malloc、free 是函数，可以覆盖，C、C++中都可以使用；
    - malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数；new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数；

16. #### 变量初始化顺序

    - 类的成员变量使用列表初始化时，顺序与构造函数中传参顺序无关，只与类成员定义顺序有关；使用函数初始化时，只与初始化顺序有关；
    - 类中 const 成员常量必须在构造函数初始化列表中初始化，不能直接定义时初始化，也不能在函数体中初始化；
    - 类中 static 成员变量，只能在类外初始化；
    - **静态初始化：**编译时对静态变量和常量进行初始化；
    - **动态初始化：**需要经过函数调用才能完成的初始化。

17. #### C++ 执行 main 之前的操作

    - 初始化栈指针；
    - 静态变量或全局变量的初始化；
    - main 函数参数的压栈；
    - 标准输入输出流的初始化。

18. #### 为什么堆比栈快

    - **分配和释放：**堆在分配和释放时都要调用函数（new delete），比如分配时会到堆空间去寻找足够大小的空间（多次分配释放后会造成空洞），这些都会花费一定的时间，而栈却不需要这些。
    -  **访问时间：**访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。 

19. #### 变量的声明和定义有什么区别

    为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。

20. #### 设置地址初值

    无论在什么平台地址长度和整型数据的长度是一样的，即一个整型数据可以强制转换成地址指针类型，只要有意义即可。

    ~~~
    int *ptr = (int*)0x67a9;  
    *ptr = 0xaa66;  
    ~~~

21. #### 拷贝构造函数和赋值构造函数的区别

    - 拷贝构造函数生成新的类对象，而赋值运算符不能；
    - 由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作；
    - 赋值运算中如果原来的对象中有内存分配要先把内存释放掉。

22. #### 一趟翻转链表

    ~~~
    #include <iostream>
    using namespace std;
    
    struct ListNode {
        int val;
        struct ListNode *next;
        ListNode(int x) : val(x), next(NULL) {}
    };
    
    class List {
    private:
        ListNode* head;
    public:
        void Insert(int val) {
            if (head == NULL) {
                head = new ListNode(val);
                return;
            }
            ListNode* p = head;
            while (p->next != NULL)
                p = p->next;
            ListNode* NewNode = new ListNode(val);
            p->next = NewNode;
        }
        void Print() {
            ListNode* p = head;
            while (p != NULL) {
                cout << p->val << " ";
                p = p->next;
            }
            cout << endl;
        }
        void Reverse() {
            ListNode* pre = nullptr;
            ListNode* cur = head;
            ListNode* nex = head;
            while (cur != nullptr) {
                nex = cur->next;
                cur->next = pre;
                pre = cur;
                cur = nex;
            }
            head = pre;
        }
    };
    
    int main()
    {
        List L;
        L.Insert(1);
        L.Insert(2);
        L.Insert(3);
        L.Print();
        L.Reverse();
        L.Print();
    
        return 0;
    }
    ~~~

23. #### 两个栈实现一个队列

    可以用两个栈能够实现一个队列的功能，但不能用两个队列能否实现一个栈的功能，因为栈是先进后出，将两个栈连在一起，就是先进先出。而队列是现先进先出，无论多少个连在一起都是先进先出，而无法实现先进后出。

24. #### typedef 和 define 的区别

    - **用法不同：**typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏；
    - **执行时间不同：**typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查；
    - **作用域不同：**typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的；

25. #### 类型转换

    - **static_cast：**

      - 执行非多态转换或用于基本数据类型之间的转换，如把 double 转换成 int；
      - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
      - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的；

      ~~~
      double age = 13.9;
      int cpp_age = static_cast<int>(age);
      ~~~

    - **const_cast：**

      - 可以用于 const 关键字的去除，只针对指针、引用、this 指针；
      - 类中的常成员函数中的成员变量是不可以被改变的，const_cast 也可以利用于掉常成员函数中变量的 const 限制，使得它可以被修改。

      ~~~
      const int n = 5;
      int* k = const_cast<int*>(&n);
      int& m = const_cast<int&>(n);
      ~~~

    - **dynamic_cast：**

      - 用于虚函数父类于子类之间的指针或引用的转换，使用的前提就是必须要有虚函数。有额外开销，非必要不适用。只有向下转换父类转子类时才会调用，判断是否安全。

    - **reinterpret_cast：**

      - 类似于C语言显示强制转换，不存在检查，在编译阶段直接转换、强制赋值。但未知是否出错，且后果自负，慎重使用。

      ~~~
      int n = 1;
      int* p = reinterpret_cast<int*>(n);
      char* pCh = reinterpret<char*>(p);
      ~~~

      

      

    



